<!DOCTYPE html>
<html>
<head>
  <title>Title of the document</title>

  <script src="d3.v4.js"></script>
  <script src="node_modules/socket.io-client/dist/socket.io.js"></script>

  <style>
    body {
      background-image: url('stars.jpg')
    }

    .button {
      border: 5px outset #888;
    }
    .button:hover { border-style: solid; }
    .button:active, .button.selected { border-style: inset; }

    #editor {
      width: 220px;
      max-height: 90vh;
      position: fixed;
      left: 5px;
      top: 10px;
      background-color: white;
      z-index: 2000;
      overflow: auto;
    }

    #editor #collapse {
      background-color: azure;
      border: outset 3px gray;
      width: 214px;
      height: 14px;
    }

    #editor #collapse:hover { border-style: solid; }
    #editor #collapse:active { border-style: inset; }

    #editor.collapsed {
      height: 20px;
    }

    #editor img.tile {
      width: 100px;
      border: 5px transparent solid;
    }

    #editor img.tile:hover { border: 5px solid #8F8; }
    #editor img.tile.active { border: 5px inset #8F8; }

    #editorTiles {
      margin: 2em 0px;
    }

    #openUploaderButton, #openOptionsButton {
      margin: 1em auto;
      width: 80%;
      display: block;
    }

    #uploadDialog, #optionsDialog {
      position: fixed;
      left: 25vw;
      top: 10vh;
      width: 50vw;
      height: 250px;
      margin: auto;
      z-index: 2000;
      background-color: white;
      box-shadow: 0px 0px 5px black;
      text-align: center;
    }

    #uploadInstructions {
      font-family: 'Arial';
      margin-top: 30px;
    }

    #uploadClose, #optionsClose {
      display: inline-block;
      float: right;
      content: 'âœ–'; /* UTF-8 symbol */
      padding: 10px;
      cursor: pointer;
    }

    #uploadInput {
      display: block;
      margin: 2em auto 1em auto;
      width: 20vw;
    }

    #uploadButton {
      display: block;
      margin: 2em auto;
      width: 20vw;
    }

    .uploadOption {
      display: block;
      margin: 1em auto;
    }

  </style>
</head>
<body>
  <div>
  <script>
    // ----------------------------------------------------------------
    // Socket
    // ----------------------------------------------------------------
    var socket = io()

    // Adding to the world
    socket.on('addTile', function (data) {
      addQueue(data.id, data.type) 
    })

    socket.on('subtractTile', subtractTile)

    socket.on('newTile', function (data) {
      console.log('new tile', data)
      tileDescriptions[data.hash] = { url: data.url }
      renderEditorTiles()
    })

    socket.on('editTile', function (data) {
      console.log('edit tile', data)
      editDescription(data.tile, data.changes)
      editTile(data.tile, data.changes)
    })

    socket.on('deleteTile', function (data) {
      console.log('delete tile', data)
      delete tileDescriptions[data]
      
      renderEditorTiles()
    })

    // Initial synchronizing
    var queue = []
    var synced = false

    socket.on('roomTiles', function (data) { 
      console.log('roomTiles', data)
      for (var id in data) {
        addQueue(id, data[id])
      }
    })

    socket.on('roomDescription', function (data) {
      console.log('roomDescription', data)
      synced = true
      for (var name in data) {
        tileDescriptions[name] = data[name]
      }
      popQueue()
      renderEditorTiles()
    })

    socket.on('alert', function (message) {
      alert(message)
    })

    function addQueue (id, type) {
      if (synced) {
        if (tileDescriptions[type]) {
          addTile(id, type)
        } else {
          console.log('No description for ' + type)
        }
      } else {
        queue.push({id: id, type: type})
      }
    }

    function popQueue () {
      queue.forEach(function (tile) {
        if (tileDescriptions[tile.type]) {
          addTile(tile.id, tile.type)
        } else {
          console.log('No description for ' + tile.type)
        }
      })
      queue = []
    }


    // ----------------------------------------------------------------
    // Create world
    // ----------------------------------------------------------------
    var world = d3.select('body')
      .append('div')
      .attr('id', 'world') 
      .style('width', '2000px')
      .style('height', '2000px')

    // ----------------------------------------------------------------
    // User Avatars
    // ----------------------------------------------------------------
    var avatars = {
      amazon: {
        art: {
          standing: [
            'amazon-rear.gif',
            'amazon-rear-right.gif',
            'amazon-right.gif',
            'amazon-front-right.gif',
            'amazon-front.gif',
            'amazon-front-left.gif',
            'amazon-left.gif',
            'amazon-rear-left.gif'
          ]
        }
      }
    }

    var characters = [{trajectory: [], avatar: 'amazon', action: 'standing', direction: 4, i: 0, j: 16, z: 1}]
    var activeCharacter = characters[0]

    renderAvatars()

    function renderAvatars () {
      world.selectAll('.avatar')
        .data(characters)
        .enter()
        .append('img')
        .attr('class', 'avatar')
        .attr('src', avatarUrl)
        .style('position', 'absolute')

      var bodies = world.selectAll('.avatar')
        .each(function (data) {
          var sprite = d3.select(this)

          characterAction(data)
          positionCharacter(sprite, data)
        })

      setTimeout(renderAvatars, 20)

      function characterAction (data) {
        var nextTile = data.trajectory[0]
        var tileAfter = data.trajectory[1]
        var grid = [data.i, data.j, data.z]

        if (nextTile) {
          if (tileAfter) {
            console.log(angleBetweenTiles(tileAfter, grid))
          }

          if (Math.abs(grid[0] - nextTile[0]) < 0.1 && Math.abs(grid[1] - nextTile[1]) < 0.1) {
            grid[0] = nextTile[0]
            grid[1] = nextTile[1]
            data.trajectory.shift()
          } else {
            if (grid[0] > nextTile[0]) {
              grid[0] -= 0.05
            } else {
              grid[0] += 0.05
            }
            if (grid[1] > nextTile[1]) {
              grid[1] -= 0.05
            } else {
              grid[1] += 0.05
            }
          }

          data.i = grid[0]
          data.j = grid[1]
          data.z = grid[2]
        }
      }

      function positionCharacter (sprite, data) {
        var grid = [data.i, data.j, data.z]
        var px = offset(grid2pixel(grid))

        sprite
          .style('left', px[0] + 'px')
          .style('top', px[1] + 'px')
          .style('z-index', px[2])
          .style('height', '160px')
          .style('width', '100px')
      }

      function avatarUrl (character) {
        var avatar = character.avatar
        var direction = character.direction
        var url = avatars[avatar].art['standing'][direction]
        return url
      }

      function offset (px) {
        px[0] += 15
        px[1] -= 80
        return px
      }
    }
 
    // ----------------------------------------------------------------
    // Tiler
    // ----------------------------------------------------------------
    var tiles = {}
    var tileDescriptions = {
      wireframe: {
        url: 'wireframe.png',
        hideInEditor: true
      },
      negative: {
        url: 'negative.png',
        hideInEditor: true
      }
    }

    var drawing = false
    var erasing = false
    var elevation = 0
    var selectedTile = 'cobblestone'
    var editing = false

    var wireframe = createTile('wireframe')
 
    function createTile (type) {
      var tile = world.append('img')
        .attr('src', tileDescriptions[type].url)
        .style('position', 'absolute')

      return tile
    }

    function grid2id (grid) {
      return String(grid[0]) + ',' + String(grid[1]) + ',' + String(grid[2])
    }

    function id2grid (id) {
      return id.split(',').map(function (loc) { return Number(loc) })
    }
    
    function tile2grid (tile) {
      var tile = tile
      return [Number(tile.attr('i')), Number(tile.attr('j')), Number(tile.attr('z'))]
    }

    function pixel2grid (cursor) {
      var iso = [],
          x = cursor[0],
          y = cursor[1],
          z = cursor[2] || elevation
 
      y += z * 32 - 25
 
      iso[0] = Math.floor(x / 128 - y / 64)
      iso[1] = Math.floor(x / 128 + y / 64)
      iso[2] = z
  
      return iso
    }
 
    function grid2pixel(iso) {
      var px = [],
          i = iso[0],
          j = iso[1],
          h = iso[2]

      // Rotate
      px[0] = i * 64  + j * 64
      px[1] = -i * 32 + j * 32
      px[2] = -i + j + h 
 
      px[1] -= h * 32

      return px 
    }

    function angleBetweenTiles (reference, destination) {
      var px1 = grid2pixel(reference)
      var px2 = grid2pixel(destination)

      return Math.atan2(px2[1] - px1[1], px2[0] - px1[0]) * 180 / Math.PI
    }

    function closestVisible (cursor) {
      var highestHeight = -Infinity
      var highestId

      for (var id in tiles) {
        var tileLocation = id2grid(id)
        if (highestHeight < tileLocation[2]) {
          cursor[2] = tileLocation[2]
          var clickLocation = pixel2grid(cursor)

          if (tileLocation[0] === clickLocation[0] && tileLocation[1] === clickLocation[1]) {
            highestHeight = tileLocation[2]
            highestId = id
          }
        }
      }
      return highestId
    }


    function findPath (origin, target) {
      // Breadth first search. Not very optimized.
      var queue = [{path: [], current: origin}]
      var seen = {}

      while (queue.length > 0) {
        var info = queue.shift()
        var tile = info.current
        var path = info.path.slice(0)

        path.push(tile)

        if (tile[0] === target[0] && tile[1] === target[1] && tile[2] === target[2]) {
          path.shift()
          return path
        }

        var directions = {
          upright: [tile[0] + 1, tile[1], tile[2]],
          dnright: [tile[0], tile[1] + 1, tile[2]],
          upleft:  [tile[0], tile[1] - 1, tile[2]],
          dnleft:  [tile[0] - 1, tile[1], tile[2]]
        }

        var keys = Object.keys(directions)
        shuffle(keys)

        for (var index in keys) {
          var grid = directions[keys[index]]
          var id = grid2id(grid)
          var above = grid.slice(0)
          above[2] = grid[2] + 1

          if (tiles[id] && !tiles[above] && seen[id] === undefined) {
            seen[id] = true
            queue.push({path: path, current: id2grid(id)})
          }
        }
      }
      
      console.log('nothing found')

      /**
       * Shuffles array in place.
       * @param {Array} a items The array containing the items.
       */
      function shuffle(a) {
        var j, x, i;
        for (i = a.length; i; i--) {
          j = Math.floor(Math.random() * i);
          x = a[i - 1];
          a[i - 1] = a[j];
          a[j] = x;
        }
      }
    }

    function editDescription (name, changes) {
      for (var change in changes) {
        tileDescriptions[name][change] = changes[change]
      }
    }

    function applyOffset (px, tileType) {
      var desc = tileDescriptions[tileType]
      var xOffset = Number(desc.xOffset)
      var yOffset = Number(desc.yOffset)

      if (!isNaN(xOffset)) {
        px[0] += xOffset
      }
      if (!isNaN(yOffset)) {
        px[1] -= yOffset
      }

      return px
    }

    function allowedTiles () {
      var available = []
      for (var name in tileDescriptions) {
        if (!tileDescriptions[name].hideInEditor) {
          available.push(name)
        }
      }
      return available
    }


    // ----------------------------------------------------------------
    // Tile Creation
    // ----------------------------------------------------------------
    function addTile (id, type, sendSocket) {
      if (!tiles[id] && tileDescriptions[type]) {
        var grid = id2grid(id)
        var px = applyOffset(grid2pixel(grid), type)

        var tile = createTile(type)

        tile
          .style('left', px[0] + 'px')
          .style('top', px[1] + 'px')
          .style('z-index', px[2])
          .attr('class', 'tile-' + type)
          .attr('i', grid[0])
          .attr('j', grid[1])
          .attr('z', grid[2])

        if (tileDescriptions[type].filter) {
          tile
            .style('filter', tileDescriptions[type].filter)
        }

        if (!document.hidden) {
          tile.style('top', px[1] - 500 + 'px')
          tile.transition().ease(d3.easeBounce)
            .style('top', px[1] + 'px')
        }

        tiles[id] = tile

        if (sendSocket) {
          socket.emit('addTile', {id: id, type: type})
        }
      }
    }

    function editTile (name, changed) {
      var tiles = world.selectAll('img.' + 'tile-' + name)

      tiles.each(function (a) {
        var tile = d3.select(this)

        if (changed.xOffset !== undefined || changed.yOffset !== undefined) {
          var grid = tile2grid(tile)
          var px = applyOffset(grid2pixel(grid), name)

          if (changed.xOffset !== undefined) {
            tile
              .style('left', px[0] + 'px')
          }
          if (changed.yOffset !== undefined) {
            tile
              .style('top', px[1] + 'px')
          }
          if (changed.filter !== undefined) {
            tile
              .style('filter', changed.filter)
          }
        }
      })

      if (changed.filter !== undefined) {
        d3.select('#editor #img-' + name)
          .style('filter', changed.filter)
      }
    }

    function subtractTile (id, sendSocket) {
      if (tiles[id]) {
        var tile = tiles[id] 
        var top = Number(tile.style('top').substr(0, tile.style('top').length - 2))

        if (!document.hidden) {
          tile.transition().ease(d3.easeLinear)
            .style('top', top + 300 + 'px')
            .style('opacity', 0)
            .remove()
        } else {
          tile.remove()
        }

        delete tiles[id]

        if (sendSocket) {
          socket.emit('subtractTile', id)
        }
      }
    }


    // ----------------------------------------------------------------
    // Create editor toolbar
    // ----------------------------------------------------------------
    var editor = d3.select('body')
      .append('div')
      .attr('id', 'editor')
      .attr('class', 'collapsed')

    var collapseBar = editor
      .append('div')
      .attr('id', 'collapse')
      .on('click', function () {
        if (editor.attr('class') !== 'collapsed') {
          editor.attr('class', 'collapsed')
          editing = false
          wireframe.style('display', 'none')
          d3.selectAll('.guideTile').remove()
        } else {
          editor.attr('class', '')
          editing = true
          wireframe.style('display', 'block')
        }
      })

    var lowerElevationButton = editor
      .append('img')
      .attr('class', 'button')
      .attr('src', 'lower.png')
      .on('click', function () {
        elevation -= 1

//        d3.selectAll('img.terrain')
//          .each(paintTerrain)
      })

    var higherElevationButton = editor
      .append('img')
      .attr('class', 'button')
      .attr('src', 'higher.png')
      .on('click', function () {
        elevation += 1

//        d3.selectAll('img.terrain')
//          .each(paintTerrain)

        console.log(elevation)
      })

/*
    function paintTerrain () {
      var z = Number(this.getAttribute('z'))
      if (z < elevation) {
        d3.select(this)
          .style('opacity', 0.4)
          .style('filter', '')

      } else if (z === elevation) {
        d3.select(this)
          .style('opacity', 1)
          .style('filter', '')
      } else {
        d3.select(this)
          .style('opacity', 0.8)
          .style('filter', 'brightness(20%)')
      }
    }
*/

    var editorTiles = editor
      .append('div')
      .attr('id', 'editorTiles')

    function renderEditorTiles () {
      var tiles = editorTiles.selectAll('img.tile')
        .data(allowedTiles())

      tiles
        .enter()
        .append('img')
        .attr('class', 'tile')
        .attr('id', function (a) { return 'img-' + a })
        .attr('src', function (a) { return tileDescriptions[a].url })
        .style('filter', function (a) { return tileDescriptions[a].filter })
        .on('click', selectTile)

     tiles
        .exit()
        .remove()


      selectTile(selectedTile)
    }

    function selectTile (tileName) {
      if (tileName) {
        editorTiles.selectAll('img.tile')
          .attr('class', 'tile')

        editorTiles.select('#img-' + tileName)
          .attr('class', 'tile active')

        selectedTile = tileName
  
        // If tile options editor is open
        refreshOptions()
      }
    }

    var openUploaderButton = editor
      .append('button')
      .attr('id', 'openUploaderButton')
      .text('New tile')
      .on('click', openUploader)

    var openOptionsButton = editor
      .append('button')
      .attr('id', 'openOptionsButton')
      .text('Tile Options')
      .on('click', openOptions)

    // ----------------------------------------------------------------
    // Mouse events
    // ----------------------------------------------------------------
    world.on('mousedown', function (a, b) {
      if (editing) {
        var cursor = d3.mouse(this)
        var grid = pixel2grid(cursor)
        var id = grid2id(grid)

        d3.event.preventDefault();

        if (tiles[id]) {
          drawing = false
          erasing = true
        } else {
          drawing = true
          erasing = false
        }

        // Trigger redraw
        mousemove.call(this)
      } else {
        var cursor = d3.mouse(this)
        var current = [Math.round(activeCharacter.i), Math.round(activeCharacter.j), Math.round(activeCharacter.z - 1)]
        var target = closestVisible(cursor)
 
        if (target) {
          var grid = id2grid(target)
          var path = findPath(current, grid)
          if (path) {
            activeCharacter.trajectory = path
//            /* Visualize Path
            path.forEach(function (d) {
              var id = grid2id(d)
              if (tiles[id]) {
                tiles[d].style('opacity', 0)
                tiles[d].transition().duration(500).style('opacity', 1)
              } else {
                console.log('No tile towards path', id, tiles[id])
              }
            })
//          */
          }
        }
      }
    })

    world.on('mouseup', function (a, b) {
      if (editing) {
        d3.event.preventDefault();

        drawing = false
        erasing = false

        // Trigger redraw
        mousemove.call(this)
      }
    })
 
    world.on('mousemove', mousemove) 

    var guideTiles = []

    function mousemove () {
      if (editing) {
        var cursor = d3.mouse(this)
        var grid = pixel2grid(cursor)
        var px = grid2pixel(grid)
        var id = grid2id(grid)

        if (drawing || (!erasing && !tiles[id])) {
          var url = tileDescriptions[selectedTile].url
          var filter = tileDescriptions[selectedTile].filter

          var px = applyOffset(px, selectedTile)

          wireframe
            .style('left', px[0] + 'px')
            .style('top', px[1] + 'px')
            .style('z-index', px[2] + 1)

          if (wireframe.attr('src') !== url) {
            wireframe
              .attr('src', url)
              .style('filter', filter)
          }
        } else {
          var url = tileDescriptions['negative'].url

          wireframe
            .style('left', px[0] + 'px')
            .style('top', px[1] + 'px')
            .style('z-index', px[2] + 1)

          if (wireframe.attr('src') !== url) {
            wireframe
              .attr('src', url)
              .style('filter', '')
          }
        }

        if (synced) {
          if (drawing) {
            addTile(id, selectedTile, true)
          } else if (erasing) {
            subtractTile(id, true)
          }
        }

        // Guide Tiles
        var newGuideTiles = {}
        for (var i=-4; i<=4; i++ ) {
          for (var j=-4; j<=4; j++) {
            var guideGrid = [grid[0] + i, grid[1] + j, grid[2] - 1]
            var guidePx = grid2pixel(guideGrid)
            var guideId = grid2id(guideGrid)
            newGuideTiles[guideId] = {grid: guideGrid, id: guideId, px: guidePx}
          }
        }

        // This is kinda bullshit I gotta do the difference operator manually here
        for (var k=0; k<guideTiles.length; k++) {
          var tile = guideTiles[k]
          var id = tile.id

          if (!newGuideTiles.id) {
            // Remove tiles that are no longer relevant
            guideTiles.splice(k, 1)
            k-- 
          } else {
            // Exclude already tracked tiles
            delete newGuideTiles[id]
          }
        }

        for (var id in newGuideTiles) {
          guideTiles.push(newGuideTiles[id])
        }

        world.selectAll('.guideTile')
          .data(guideTiles, function (d) { return d.id })
          .enter()
          .append('img')
          .attr('class', 'guideTile')
          .attr('src', 'tophat.png')
          .style('position', 'absolute')
          .style('left', function (d) { return d.px[0] + 'px' })
          .style('top', function (d) { return d.px[1] + 'px' })
          .style('z-index', function (d) { return d.px[2] })
          .style('opacity', 0)

        world.selectAll('.guideTile')
          .style('opacity', function (d) { 
            var distance = Math.sqrt(Math.pow(Math.abs(d.grid[0] - grid[0]), 2) + Math.pow(Math.abs(d.grid[1] - grid[1]), 2))
            var max = 5.65
            return (max - distance) / max
          })

        world.selectAll('.guideTile')
          .data(guideTiles, function (d) { return d.id })
          .exit()
          .remove()
      }
    }

    // ----------------------------------------------------------------
    // File uploader
    // ----------------------------------------------------------------
    var file

    var uploadDialog = d3.select('body')
      .append('div')
      .attr('id', 'uploadDialog')
      .attr('class', 'modal')
      .style('display', 'none')

    function openUploader () {
      d3.select('body').selectAll('.modal')
        .style('display', 'none')
      uploadDialog.style('display', 'block')
    }

    function closeUploader () {
      uploadDialog.style('display', 'none')
    }

    var uploadClose = uploadDialog
      .append('div')
      .attr('id', 'uploadClose')
      .text('x')
      .on('click', closeUploader)

    var uploadInstructions = uploadDialog
      .append('p')
      .attr('id', 'uploadInstructions')
      .text('Upload a .png or .gif 128x96')
      
    var uploadTileInput = uploadDialog
      .append('input')
      .attr('id', 'uploadInput')
      .attr('type', 'file')
      .on('change', stageFile)

    var uploadButton = uploadDialog
      .append('button')
      .attr('id', 'uploadButton')
      .text('Upload image')
      .on('click', sendFile)

    // Stolen from: 
    // http://stackoverflow.com/questions/14788898/save-a-image-using-nodejs-expressjs-and-socket-io
    function stageFile () {
      var e = d3.event
      var files = e.target.files || e.dataTransfer.files;

      console.log(files[0])
      if (files && files[0]) {
        var extension = files[0].name.split('.')[files[0].name.split('.').length - 1]
        if (extension === 'gif' || extension === 'png') {
          if (files[0].size <= 1000000) {
            file = files[0] 
          } else {
            alert('File size of ' + (files[0].size / 1000000).toFixed(2) + 'MB is too large. Try uploading a .png or .gif under 1MB.')
          }
        } else {
          alert('File type ' + extension + ' is not permitted. Please try a .png or .gif file type.')
        }
      }
    }

    function sendFile () {
      if (file) {
        var reader = new FileReader()

        reader.onload = function (e) {
          console.log('Sending file...')
          var buffer = e.target.result
          socket.emit('uploadTile', file.name, buffer)
          closeUploader()

          socket.once('newTile', function (data) {
            // Wait for the description to get set
            setTimeout(function () {
              selectTile(data.hash)
              openOptions()
            }, 100)
          })
        }

        reader.readAsBinaryString(file)
      }
    }

    // ----------------------------------------------------------------
    // Tile Options
    // ----------------------------------------------------------------
    var optionsDialog = d3.select('body')
      .append('div')
      .attr('id', 'optionsDialog')
      .attr('class', 'modal')
      .style('display', 'none')

    function openOptions () {
      refreshOptions()
      d3.select('body').selectAll('.modal')
        .style('display', 'none')
      optionsDialog.style('display', 'block')
    }

    function closeOptions () {
      optionsDialog.style('display', 'none')
    }

    var optionsClose = optionsDialog
      .append('div')
      .attr('id', 'optionsClose')
      .text('x')
      .on('click', closeOptions)

    var previewScreen = optionsDialog
      .append('div')
      .style('position', 'relative')
      .style('top', '80px')
      .style('left', '60px')

    var preview = previewScreen
      .append('img')

    var reference = previewScreen
      .append('img')
      .attr('src', tileDescriptions['wireframe'].url)
      .style('position', 'absolute')
      .style('left', 0)
      .style('top', 0)

    var xOffset = optionsDialog
      .append('input')
      .attr('id', 'xOffset')
      .attr('type', 'number')
      .on('change', updateXOffset)

    var yOffset = optionsDialog
      .append('input')
      .attr('id', 'yOffset')
      .attr('type', 'number')
      .on('change', updateYOffset)

    function updateXOffset() {
      var offset = Number(d3.event.target.value)
      if (!isNaN(offset)) {
        preview
          .style('left', offset + 'px')
      }
    }

    function updateYOffset() {
      var offset = -Number(d3.event.target.value)
      if (!isNaN(offset)) {
        preview
          .style('top', offset + 'px')
      }
    }

    var saveOptionsButton = optionsDialog
      .append('button')
      .attr('id', 'saveOptionsButton')
      .text('Save tile options')
      .on('click', saveOptions)

    function refreshOptions () {
      var desc = tileDescriptions[selectedTile]
      if (desc) {
        var xOffset = Number(desc.xOffset) || 0
        var yOffset = -Number(desc.yOffset) || 0

        optionsDialog.select('#xOffset').property('value', xOffset)
        optionsDialog.select('#yOffset').property('value', -yOffset)

        preview
          .attr('src', desc.url)
          .style('position', 'absolute')
          .style('left', xOffset + 'px')
          .style('top', yOffset + 'px')
          .style('filter', desc.filter)


        // Is this really the best way to extract what filters are applied to the selectedTile?
        // String manipulation B.S.
        for (var i=0; i<filtersList.length; i++) {
          var input = d3.select('.filterInput[i="' + i + '"]')
          var node = input.node()

          if (node) node.value = null
        }

        if (desc.filter) {
          var filters = desc.filter.split(' ')
          for (var i=0; i<filters.length; i++) {
            var str = filters[i]
            var filterName = str.substring(0, str.indexOf('('))
            if (filterName) {

              for (var j=0; j<filtersList.length; j++) {
                if (filtersList[j].name === filterName) break
              }

              var filterInfo = filtersList[j]

              if (filterInfo.name == filterName) {
                var filterValue = str.substring(str.indexOf('(') + 1, str.indexOf(')'))

                if (filterInfo.values === 'percentage') {
                  var num = Number(filterValue.substring(0, filterValue.indexOf('%')))
                } else if (filterInfo.values === 'angle') {
                  var num = Number(filterValue.substring(0, filterValue.indexOf('deg')))
                } else if (filterInfo.values === 'length') {
                  var num = Number(filterValue.substring(0, filterValue.indexOf('px')))
                }

                var input = d3.select('.filterInput[i="' + j + '"]').node()
                  .value = num
              }
            }
          }
        }
      } else {
        preview.attr('src', '')
      }
    }

    var deleteTile = optionsDialog
      .append('button')
      .attr('id', 'deleteTile')
      .text('Delete tile.')
      .on('click', confirmDelete)

    function confirmDelete () {
      if (tileDescriptions[selectedTile]) {
        confirm('Are you sure you want to remove this tile?')
        if (confirm) {
          for (var id in tiles) {
            if (tiles[id].node().classList.contains('tile-' + selectedTile)) {
              subtractTile(id, true)
            }
          }

          closeOptions()
          socket.emit('deleteTile', selectedTile)
        }
      } else {
        alert('No tile selected')
      }
    }


    var filtersList = [
        {name: 'grayscale', values: 'percentage'},
        {name: 'sepia', values: 'percentage'},
        {name: 'saturate', values: 'percentage'},
        {name: 'hue-rotate', values: 'angle'},
        {name: 'invert', values: 'percentage'},
        {name: 'opacity', values: 'percentage'},
        {name: 'brightness', values: 'percentage'},
        {name: 'contrast', values: 'percentage'},
        {name: 'blur', values: 'length'},
        {name: 'drop-shadow', values: 'drop-shadow'}
    ]

    var filterShorthand = ''

    for (var i=0; i<filtersList.length; i++) {
      var filter = filtersList[i];

      var filterContainer = optionsDialog
        .append('div')
        .attr('class', 'filter')

      var filterName = filterContainer
        .append('span')
        .attr('class', 'filterName')
        .text(filter.name)

      if (filter.values === 'percentage' || filter.values ==='angle' || filter.values === 'length') {
        var filterInput = filterContainer
          .append('input')
          .attr('type', 'number')
          .attr('class', 'filterInput')
          .attr('i', i)
          .on('change', filterValueChanged)
      }
    }

    function filterValueChanged (a, b, c) {
      var filter =  filtersList[c[0].getAttribute('i')]

      filterShorthand = ''

      for (var i=0; i<filtersList.length; i++) {
        var input = d3.select('.filterInput[i="' + i + '"]').node()
        var value = input ? input.value : null
        var info = filtersList[i]

        if (value) {
          if (info.values === 'percentage') {
            filterShorthand += info.name + '(' + value + '%) '
          } else if (info.values === 'angle') {
            filterShorthand += info.name + '(' + value + 'deg) '
          } else if (info.values === 'length') {
            filterShorthand += info.name + '(' + value + 'px) '
          }
        }
      }

      preview
        .style('filter', filterShorthand)
    }

    function saveOptions () {
      if (tileDescriptions[selectedTile]) {
        var xOffset = Number(optionsDialog.select('#xOffset').property('value'))
        var yOffset = Number(optionsDialog.select('#yOffset').property('value'))

        var changes = {}

        if (!isNaN(xOffset) && xOffset !== Number(tileDescriptions[selectedTile].xOffset)) {
          changes.xOffset = xOffset
        }

        if (!isNaN(yOffset)) { 
          changes.yOffset = yOffset
        }

        if (filterShorthand !== tileDescriptions[selectedTile].filter) {
          changes.filter = filterShorthand
        }

        socket.emit('editTile', {tile: selectedTile, changes: changes})
      } else {
        alert('No tile selected.')
      }
    }

 </script>
</body>
</html>
